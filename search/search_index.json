{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":""},{"location":"#what-is-burrito","title":"What is burrito?","text":"<p>Burrito is a TACoS (Terraform Automation Collaboration Software) Kubernetes Operator.</p> <p></p>"},{"location":"#why-burrito","title":"Why burrito?","text":"<p><code>terraform</code> is a tremendous tool to manage your infrastructure in IaC. But, it does not come up with an out-of the box solution for managing state drift.</p> <p>Also, writing a CI/CD pipeline for terraform can be painful and depends on the tool you are using.</p> <p>Finally, currently, there is no easy way to navigate your terraform state to truly understand the modifications it undergoes when running <code>terraform apply</code>.</p> <p><code>burrito</code> aims to tackle those issues by:</p> <ul> <li>Planning continuously your terraform code and run applies if needed</li> <li>Offering an out of the box PR/MR integration so you do not have to write CI/CD pipelines for terraform ever again (not implemented yet)</li> <li>Showing your state's modifications in a simple Web UI (not implemented yet)</li> </ul>"},{"location":"#getting-started","title":"Getting started","text":""},{"location":"#quick-start","title":"Quick start","text":"<pre><code>kubectl create namespace burrito\nkubectl apply -n burrito -f https://raw.githubusercontent.com/padok-team/burrito/main/manifests/install.yaml\n</code></pre> <p>Follow our getting started guide. Further user oriented documentation is provided for additional features.</p>"},{"location":"getting-started/","title":"Getting started","text":""},{"location":"getting-started/#requirements","title":"Requirements","text":"<ul> <li>Installed kubectl command-line tool.</li> <li>Have a kubeconfig file (default location is <code>~/.kube/config</code>).</li> </ul>"},{"location":"getting-started/#1-install-burrito","title":"1. Install burrito","text":"<pre><code>kubectl create namespace burrito\nkubectl apply -n burrito -f https://raw.githubusercontent.com/padok-team/burrito/main/manifests/install.yaml\n</code></pre> <p>This will create a new namespace, <code>burrito</code>, where burrito services will live.</p> <p>Warning</p> <p>The installation manifests include <code>ClusterRoleBinding</code> resources that reference <code>burrito</code> namespace. If you are installing burrito into a different namespace then make sure to update the namespace reference.</p>"},{"location":"getting-started/#2-create-a-connection-to-a-private-repository","title":"2. Create a connection to a private repository","text":"<p>Create a Kubernetes <code>Secret</code> which looks like:</p> <pre><code>kind: Secret\nmetadata:\nname: burrito-repo\nnamespace: burrito\ntype: Opaque\nstringData:\nusername: &lt;my-username&gt;\npassword: &lt;my-password | my-access-token&gt;\nsshPrivateKey: |\n-----BEGIN OPENSSH PRIVATE KEY-----\n...\n-----END OPENSSH PRIVATE KEY-----\n</code></pre> <p>Then, create a <code>TerraformRepository</code> Kubernetes resource:</p> <pre><code>apiVersion: config.terraform.padok.cloud/v1alpha1\nkind: TerraformRepository\nmetadata:\nname: burrito\nnamespace: burrito\nspec:\nrepository:\nurl: &lt;https_or_ssh_repository_url&gt;\nsecretName: burrito-repo\n</code></pre> <p>Info</p> <p>You can also connect to a public repository by omitting <code>spec.repository.secretName</code> in your <code>TerraformLayer</code> definition.</p>"},{"location":"getting-started/#3-synchronize-a-terraform-layer","title":"3. Synchronize a terraform layer","text":"<p>After creating a <code>TerraformRepository</code> you can create a <code>TerraformLayer</code> ressource which looks like:</p> <pre><code>apiVersion: config.terraform.padok.cloud/v1alpha1\nkind: TerraformLayer\nmetadata:\nname: random-pets\nnamespace: burrito\nspec:\nterraform: version: \"1.3.1\"\npath: \"internal/e2e/testdata/random-pets\"\nbranch: \"main\"\nrepository:\nkind: TerraformRepository\nname: burrito\nnamespace: burrito\n</code></pre>"},{"location":"operator-manual/","title":"Overview","text":"<p>This guide is for administrator and operator wanting to install and configure burrito for other developers.</p> <p>Note</p> <p>Please make sure you've completed the getting started guide.</p>"},{"location":"operator-manual/advanced-configuration/","title":"Advanced configuration","text":"<p>You can configure <code>burrito</code> with environment variables.</p> Environment variable Description Default <code>BURRITO_REDIS_URL</code> the redis URL to connect to <code>redis:6379</code>"},{"location":"operator-manual/advanced-configuration/#controllers-configuration","title":"Controllers' configuration","text":"Environment variable Description Default <code>BURRITO_CONTROLLER_TYPES</code> list of controllers to start <code>layer,repository</code> <code>BURRITO_CONTROLLER_TIMERS_DRIFTDETECTION</code> period between two plans for drift detection <code>20m</code> <code>BURRITO_CONTROLLER_TIMERS_ONERROR</code> period between two runners launch when an error occurred in the controllers <code>1m</code> <code>BURRITO_CONTROLLER_TIMERS_WAITACTION</code> period between two runners launch when a layer is locked <code>1m</code> <code>BURRITO_CONTROLLER_TIMERS_FAILUREGRACEPERIOD</code> initial time before retry, goes exponential function of number failure <code>15s</code> <code>BURRITO_CONTROLLER_LEADERELECTION_ENABLED</code> whether leader election is enabled or not <code>true</code> <code>BURRITO_CONTROLLER_LEADERELECTION_ID</code> lease id used for leader election <code>6d185457.terraform.padok.cloud</code> <code>BURRITO_CONTROLLER_HEALTHPROBEBINDADDRESS</code> address to bind the health probe server embedded in the controllers <code>:8081</code> <code>BURRITO_CONTROLLER_METRICSBINDADDRESS</code> address to bind the metrics server embedded in the controllers <code>:8080</code> <code>BURRITO_CONTROLLER_KUBERNETESWEBHOOKPORT</code> port used by the validating webhook server embedded in the controllers <code>9443</code>"},{"location":"operator-manual/advanced-configuration/#servers-configuration","title":"Server's configuration","text":"Environment variable Description Default <code>BURRITO_SERVER_ADDR</code> addr the server listens on <code>:8080</code> <p>Info</p> <p>For webhook configuration see Setup a git webhook.</p>"},{"location":"operator-manual/advanced-configuration/#runners-configuration","title":"Runners' configuration","text":"<p>Currently, runners' configuration is not exposed.</p> <p>Info</p> <p>You can override some of the runner's pod spec. See override the runner pod spec documentation.</p>"},{"location":"operator-manual/architecture/","title":"Architectural Overview","text":""},{"location":"operator-manual/architecture/#components","title":"Components","text":""},{"location":"operator-manual/architecture/#the-server","title":"The server","text":"<p>The server is a REST server which exposes the API consumed by the Web UI. It has the following responsibilities:</p> <ul> <li>listener for Git webhook events</li> </ul> <p>Other features will be implemented when the Web UI will be in development.</p>"},{"location":"operator-manual/architecture/#the-repository-controller","title":"The repository Controller","text":"<p>The repository controller is a Kubernetes Controller which is only used to register <code>TerraformRepository</code> ressources.</p>"},{"location":"operator-manual/architecture/#the-layer-controller","title":"The layer Controller","text":"<p>The layer controller is a Kubernetes Controller which continuously monitors declared <code>TerraformLayer</code> ressources. It regularly starts runner pods which runs a <code>terraform plan</code> for each of your layer to check if a drift has been introduced. If so, it has the possibility to run a <code>terraform apply</code>.</p> <p>It is also responsible for running your terraform <code>plan</code> and <code>apply</code> if there is a new commit on your layer.</p> <p>It also generates <code>Leases</code> to make sure no concurrent terraform commands will be launched on the same layer at the same time.</p>"},{"location":"operator-manual/architecture/#the-redis-instance","title":"The redis instance","text":"<p>The redis instance is used to store the binary generated by <code>terraform plan</code> before running the <code>apply</code>. We also store information about the <code>plan</code>/<code>apply</code> output to print it in the resources' statuses</p>"},{"location":"operator-manual/architecture/#implementation","title":"Implementation","text":"<p>The operator has been bootstrapped using the <code>operator-sdk</code>.</p> <p>The CLI used to start the different components is implemented using <code>cobra</code>.</p>"},{"location":"operator-manual/architecture/#the-terraformlayer-controller","title":"The TerraformLayer Controller","text":"<p>The status of a <code>TerraformLayer</code> is defined using the conditions standards defined by the community.</p> <p>4 conditions are defined for a layer:</p> <ul> <li><code>IsPlanArtifactUpToDate</code>. This condition is used for drift detection. The evaluation is made by compraing the timestamp of the last <code>terraform plan</code> which ran and the current date. The timestamp of the last plan is \"stored\" using an annotation.</li> <li><code>IsApplyUpToDate</code>. This condition is used to check if an <code>apply</code> needs to run after the last <code>plan</code>. Comparison is made by comparing a checksum of the last planned binary and a checksum last applied binary stored in the annotations.</li> <li><code>IsLastRelevantCommitPlanned</code>. This condition is used to check if a new commit has been made to the layer and need to be applied. It is evaluated by comparing the commit used for the last <code>plan</code>, the last commit which intoduced changes to the layer and the last commit made to the same branch of the repository. Those commits are \"stored\" as annotations.</li> <li><code>IsInfailureGracePeriod</code>. This condition is used to check if a terraform workflow has already failed. If so, we use an exponential backoff strategy before restarting a runner on the given layer.</li> </ul> <p>Info</p> <p>We use annotations to store information because we do not want to rely too heavily on the uptime of the redis instance.</p> <p>With those 4 conditions, we defined 4 states:</p> <ul> <li><code>Idle</code>. This is the state of a layer if no runner needs be started</li> <li><code>PlanNeeded</code>. This is the state of a layer if burrito needs to start a <code>plan</code> runner</li> <li><code>ApplyNeeded</code>. This is the state of a layer if burrito needs to start an <code>apply</code> runner</li> <li><code>FailureGracePeriod</code>. This is the state of a layer if a <code>plan</code> or <code>apply</code> runner has failed</li> </ul> <p>Info</p> <p>If you use <code>dry</code> remediation strategy and an apply is needed, the layer will stay in the <code>ApplyNeeded</code> as long as it does not need to enter the <code>PlanNeeded</code>.</p> <p>The layer controller also generates the Kubernetes leases to avoid concurrent use of terraform on the same layer.</p> <p>Info</p> <p>N.B. We use lease objects in order to not have to rely on the redis instance for layer locking.</p> <p>The layer controller is also responsible for registering runner pods to the Kubernetes API. We decided to use dynamic runners in order to be able to associate specific service accounts for each layers (each layer does not need the same access right to be planned and applied).</p>"},{"location":"operator-manual/architecture/#the-runners","title":"The runners","text":"<p>The runner image implementation heavily relies on golang libraries provided by hashicorp such as <code>tfexec</code>, <code>releases</code> and <code>product</code> which allows us to dynamically download and use any version of therraform binary. Thus, we support any existing version of terraform.</p>"},{"location":"operator-manual/git-webhook/","title":"Setup a Git Webhook","text":"<p>Create a webhook (with a secret!) in the repository you want to receive events from.</p> <p>Then create a secret:</p> <pre><code>kind: Secret\nmetadata:\nname: burrito-webhook-secret\nnamespace: burrito\ntype: Opaque\nstringData:\nburrito-webhook-secret: &lt;my-webhook-secret&gt;\n</code></pre> <p>Add the webhook secret as an environment variable of the <code>burrito-server</code>. The variables depends on your git provider.</p> Git provider Environment Variable GitHub <code>BURRITO_SERVER_WEBHOOK_GITHUB_SECRET</code> GitLab <code>BURRITO_SERVER_WEBHOOK_GITLAB_SECRET</code>"},{"location":"operator-manual/pr-mr-workflow/","title":"PR/MR Workflow","text":"<p>Info</p> <p>In this documentation all references to pull requests can be change to merge requests for GitLab. However, the resulting Kubernetes object will still be named <code>TerraformPullRequest</code>.</p>"},{"location":"operator-manual/pr-mr-workflow/#components","title":"Components","text":""},{"location":"operator-manual/pr-mr-workflow/#the-server","title":"The server","text":"<p>Info</p> <p>For mor information about the server, see the architectural overview documentation.</p> <p>Upon receiving a Pull Request creation event, the server creates a <code>TerraformPullRequest</code> resource.</p> <p>Upon receiving a Pull Requestion  deletion event, the server deletes the related <code>TerraformPullRequest</code> resource.</p>"},{"location":"operator-manual/pr-mr-workflow/#the-pull-request-controller","title":"The pull request controller","text":"<p>The pull request controller is a Kubernetes controller which continuously monitors declared <code>TerraformPullRequest</code> resources.</p> <p>It is responsible for creating temporary <code>TerraformLayer</code> resources linked to the Pull Request it was generated from. Once all the <code>TerraformLayer</code> have planned, it will send a comment contianing the plan results to the pull request.</p> <p></p>"},{"location":"operator-manual/pr-mr-workflow/#implementation","title":"Implementation","text":"<p>The status of a <code>TerraformPulLRequest</code> is defined using the conditions standards defined by the community.</p> <p>3 conditions ared defined for a pull request:</p> <ul> <li><code>IsLastCommitDiscovered</code>. This condition is used to check if we received a new commit on the pull request by comparing the latest commit on the branch and the last discovered commit.</li> <li><code>AreLayersStillPlanning</code>. This condition is used to check if all the temporary layers have finished planning. This is done by checking all the resulting <code>TerraformLayer</code> statuses.</li> <li><code>IsCommentUpToDate</code>. This condition is used to check if the controller needs to sen a comment to a pull request. This is checked by comparing the last discovered commit and the last commit for which a comment was already sent.</li> </ul> <p>Info</p> <p>We use annotations to store information.</p> <p>With those 3 conditions, we defined 3 states:</p> <ul> <li><code>Idle</code>. This is the state of a pull request if nothing needs to be done.</li> <li><code>DiscoveryNeeded</code>. This is the state of a pull request if the controller needs to check which layers are affected on the given pull request.</li> <li><code>CommentNeeded</code>.  This is the state of a pull request if the controller needs to send a comment to the git provider's API.</li> </ul>"},{"location":"operator-manual/pr-mr-workflow/#configuration","title":"Configuration","text":"Environment variable Description <code>BURRITO_CONTROLLER_GITHUBCONFIG_APITOKEN</code> the API token to send comment to GitHub's API <code>BURRITO_CONTROLLER_GITLABCONFIG_APITOKEN</code> the API token to send comment to GitLab's API"},{"location":"user-guide/","title":"Overview","text":"<p>This guide is for developers who have burrito installed for them and are managing layers.</p> <p>Note</p> <p>Please make sure you've completed the getting started guide.</p>"},{"location":"user-guide/override-runner/","title":"Override the runner pod spec","text":"<p>Both <code>TerraformRepository</code> and <code>TerraformLayer</code> expose a <code>spec.overrideRunnerSpec</code> map field.</p> <p>If the field is specified for a given <code>TerraformRepository</code> it will be applied by default to all <code>TerraformLayer</code> linked to it.</p> <p>If the field is specified for a given <code>TerraformLayer</code> it will take precedence over the <code>TerraformRepository</code> configuration.</p> <p>Available overrides are:</p> Fields <code>ImagePullSecrets</code> <code>Image</code> <code>Tolerations</code> <code>NodeSelector</code> <code>ServiceAccountName</code> <code>Resources</code> <code>Env</code> <code>EnvFrom</code> <code>Volumes</code> <code>VolumeMounts</code> <code>Metadata.Annotations</code> <code>Metadata.Labels</code> <p>For instance with the following configuration, all the runner pods will have the specifications described inside the <code>TerraformRepository</code>:</p> <pre><code>apiVersion: config.terraform.padok.cloud/v1alpha1\nkind: TerraformRepository\nmetadata:\nname: burrito\nnamespace: burrito\nspec:\nrepository:\nurl: https://github.com/padok-team/burrito\noverrideRunnerSpec:\nimagePullSecrets:\n- name: ghcr-creds\ntolerations:\n- effect: NoSchedule\nkey: burrito.io/production\noperator: Exists\nnodeSelector:\nproduction: \"true\"\nserviceAccountName: \"production\"\n---\napiVersion: config.terraform.padok.cloud/v1alpha1\nkind: TerraformLayer\nmetadata:\nname: random-pets\nnamespace: burrito\nspec:\nterraform:\nversion: \"1.3.1\"\npath: \"internal/e2e/testdata/random-pets\"\nbranch: \"main\"\nrepository:\nkind: TerraformRepository\nname: burrito\nnamespace: burrito\n</code></pre> <p>In the following case, <code>tolerations</code> and <code>nodeSelector</code> will be merged:</p> <pre><code>apiVersion: config.terraform.padok.cloud/v1alpha1\nkind: TerraformRepository\nmetadata:\nname: burrito\nnamespace: burrito\nspec:\nrepository:\nurl: https://github.com/padok-team/burrito\noverridePodSpec:\nimagePullSecrets:\n- name: ghcr-creds\ntolerations:\n- effect: NoExecute\nkey: burrito.io/production\noperator: Exists\nnodeSelector:\nproduction: \"true\"\nserviceAccountName: \"production\"\n---\napiVersion: config.terraform.padok.cloud/v1alpha1\nkind: TerraformLayer\nmetadata:\nname: random-pets\nnamespace: burrito\nspec:\nterraform:\nversion: \"1.3.1\"\npath: \"internal/e2e/testdata/random-pets\"\nbranch: \"main\"\nrepository:\nkind: TerraformRepository\nname: burrito\nnamespace: burrito\noverrideRunnerSpec:\ntolerations:\n- effect: NoSchedule\nkey: burrito.io/production\noperator: Exists\nnodeSelector: {}\n</code></pre> <p>Resulting in the following <code>podSpec</code>:</p> <pre><code>tolerations:\n- effect: NoSchedule\nkey: burrito.io/production\noperator: Exists\nnodeSelector:\nproduction: \"true\"\n</code></pre>"},{"location":"user-guide/remediation-strategy/","title":"Choose a remediation strategy","text":"<p>Currently, 2 remediation strategies are handled.</p> Strategy Effect <code>dry</code> The operator will only run the <code>plan</code>. This is the default strategy <code>autoApply</code> If a <code>plan</code> is not up to date, it will run an <code>apply</code> <p>As for the runner spec override, you can specify a <code>spec.remediationStrategy</code> either on the <code>TerraformRepository</code> or the <code>TerraformLayer</code>.</p> <p>The configuration of the <code>TerraformLayer</code> will take precedence.</p> <p>Warning</p> <p>This operator is still experimental. Use <code>spec.remediationStrategy: \"autoApply\"</code> at your own risk.</p>"},{"location":"user-guide/terraform-version/","title":"Choose a terraform/terragrunt version","text":""},{"location":"user-guide/terraform-version/#choose-terraform-version","title":"Choose terraform version","text":"<p>Both <code>TerraformRepository</code> and <code>TerraformLayer</code> expose a <code>spec.terrafrom.version</code> map field.</p> <p>If the field is specified for a given <code>TerraformRepository</code> it will be applied by default to all <code>TerraformLayer</code> linked to it.</p> <p>If the field is specified for a given <code>TerraformLayer</code> it will take precedence over the <code>TerraformRepository</code> configuration.</p>"},{"location":"user-guide/terraform-version/#enable-terragrunt","title":"Enable Terragrunt","text":"<p>You can specify usage of terragrunt as follow:</p> <pre><code>apiVersion: config.terraform.padok.cloud/v1alpha1\nkind: TerraformLayer\nmetadata:\nname: random-pets-terragrunt\nspec:\nterraform:\nversion: \"1.3.1\"\nterragrunt:\nenabled: true\nversion: \"0.44.5\"\nremediationStrategy: dry\npath: \"internal/e2e/testdata/terragrunt/random-pets/prod\"\nbranch: \"feat/handle-terragrunt\"\nrepository:\nkind: TerraformRepository\nname: burrito\nnamespace: burrito\n</code></pre> <p>Info</p> <p>This configuration can be specified at the <code>TerraformRepository</code> level to be enabled by default in each of its layers.</p>"}]}